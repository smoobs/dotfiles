#!/usr/bin/env perl

use v5.10;

use autodie;
use strict;
use warnings;

use File::Find;
use GD;
use Image::Size;
use JSON;
use List::Util qw( max shuffle sum );

use constant WIDTH => 2560;

my @image      = ();
my $avg_aspect = 0;
find {
  wanted => sub {
    return unless -f;
    return unless /\.jpg$/i;
    my $name = $_;
    my ( $width, $height ) = imgsize $name;
    $avg_aspect += $width / $height;
    push @image,
     {name   => $name,
      width  => $width,
      height => $height,
      aspect => $width / $height
     };
  },
  no_chdir => 1
 },
 ".";

$avg_aspect /= @image;

my @img = shuffle @image;
my $use = 1 + int sqrt scalar @img;

my @spec = ();
my $dir  = 1;
while ( @img >= $use ) {
  push @spec,
   format_row( sort { $dir * ( $a->{aspect} <=> $b->{aspect} ) }
     splice @img,
    0, $use );
  $dir = -$dir;
}

my $out_w = WIDTH;
my $out_h = sum map { $_->{height} } @spec;

my $im = GD::Image->new( $out_w, $out_h, 1 );
my $y_pos = 0;
for my $row (@spec) {
  my $x_pos = 0;
  for my $ident ( @{ $row->{images} } ) {
    say $ident->{name};
    my $src = GD::Image->new( $ident->{name} );
    my $sw  = 1 + int( $ident->{width} * $row->{height} / $ident->{height} );
    $im->copyResampled( $src, $x_pos, $y_pos, 0, 0, $sw, $row->{height},
      $ident->{width}, $ident->{height} );
    $x_pos += $sw;
  }
  $y_pos += $row->{height};
}

{
  open my $fh, '>', 'montage.png';
  $fh->print( $im->png );
}

#say JSON->new->pretty->canonical->encode( \@spec );

sub format_row {
  my @img    = @_;
  my $height = max map { $_->{height} } @img;
  my $width  = 0;
  for my $img (@img) {
    my $iw = $img->{width} * $height / $img->{height};
    $width += $iw;
  }
  my $sh = int( $height * WIDTH / $width );
  return { height => $sh, images => \@img };
}

# vim:ts=2:sw=2:sts=2:et:ft=perl

